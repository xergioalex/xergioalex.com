# Task 2: Profile Lambda Execution and Identify Bottlenecks

## 1. Context

**Purpose:** Use AWS X-Ray to profile Lambda execution and identify the specific bottlenecks causing slow performance.

**Where:**

- AWS X-Ray console
- Lambda function: `src/functions/botFlow/`
- X-Ray integration: Add to Lambda config

**Why this matters:**

- Baseline gives us overview metrics, profiling shows us WHERE time is spent
- X-Ray traces show exact function calls, durations, and dependencies
- Identifies hot paths and slow queries
- Provides actionable data for optimization

**Dependencies:**

- Task 1 completed (baseline established)

---

## 2. Goal

Instrument botFlow Lambda with AWS X-Ray and analyze traces to identify:

- Top 5 slowest operations
- DynamoDB query patterns and durations
- External API call latencies
- Memory-intensive operations
- Initialization bottlenecks

---

## 3. Instructions

### Step 1: Enable AWS X-Ray for botFlow

1. **Update Serverless configuration:**

   Edit `serverless/services/botFlow/serverless.yml`:

   ```yaml
   functions:
     bot-flow:
       handler: src/functions/botFlow/handler.handler
       tracing: Active # Add this line
       environment:
         AWS_XRAY_CONTEXT_MISSING: LOG_ERROR
   ```

2. **Add X-Ray SDK to code:**

   ```bash
   npm install aws-xray-sdk-core
   ```

3. **Instrument AWS SDK calls:**

   Edit `src/functions/botFlow/handler.ts`:

   ```typescript
   import AWSXRay from 'aws-xray-sdk-core'
   import AWS from 'aws-sdk'

   // Wrap AWS SDK
   const capturedAWS = AWSXRay.captureAWS(AWS)

   // Use capturedAWS instead of AWS for all AWS service calls
   ```

4. **Deploy changes:**
   ```bash
   npm run sls:deploy:dev
   ```

### Step 2: Generate Representative Traffic

1. **Send test messages through all platforms:**

   ```bash
   # Slack test
   curl -X POST [webhook-url] -d '...'

   # Discord test
   curl -X POST [webhook-url] -d '...'

   # Teams test
   curl -X POST [webhook-url] -d '...'

   # Telegram test
   curl -X POST [webhook-url] -d '...'
   ```

2. **Generate at least 50 invocations** to get representative samples

3. **Include various scenarios:**
   - First-time users (creates new state)
   - Returning users (loads existing state)
   - Complex commands
   - Simple greetings
   - Error scenarios

### Step 3: Analyze X-Ray Traces

1. **Access X-Ray Console:**
   - Navigate to AWS X-Ray
   - Filter for botFlow function
   - Time range: Last hour (or when tests were run)

2. **Review Service Map:**
   - Identify all service dependencies
   - Note latencies between services
   - Look for unexpected dependencies

3. **Analyze Trace Timeline:**

   For each trace:
   - Total duration
   - Cold start overhead
   - Initialization time
   - Function execution time
   - AWS SDK call durations

4. **Filter by slowest traces:**
   - Sort by duration (longest first)
   - Analyze top 10 slowest traces
   - Identify common patterns

### Step 4: Identify DynamoDB Bottlenecks

1. **Filter traces for DynamoDB calls:**
   - Look for `GetItem`, `PutItem`, `Query` operations
   - Note duration of each operation
   - Identify sequential vs. parallel calls

2. **Analyze query patterns:**

   ```
   Questions to answer:
   - Are we making multiple sequential calls that could be batched?
   - Are we querying for data we don't use?
   - Are we using the right indexes (GSI)?
   - Are queries taking >100ms?
   ```

3. **Document findings:**
   - Which queries are slowest
   - Frequency of each query type
   - Potential for caching

### Step 5: Identify External API Bottlenecks

1. **Review external HTTP calls:**
   - DailyBot API calls
   - Platform APIs (Slack, Discord, etc.)
   - OpenAI API calls (if any)

2. **Measure latencies:**
   - P50, P90, P99 for each external service
   - Timeout configurations
   - Retry patterns

3. **Check for sequential calls:**
   - Could any be parallelized?
   - Are we waiting unnecessarily?

### Step 6: Analyze Memory Usage Patterns

1. **Review memory subsegments in X-Ray:**
   - Peak memory usage during execution
   - Memory growth patterns
   - Potential memory leaks

2. **Identify memory-intensive operations:**
   - Large object allocations
   - String concatenation in loops
   - Unnecessary data copying

### Step 7: Create Profiling Report

**Create file:** `docs/profiling-report-2026-01-26.md`

```markdown
# Lambda Profiling Report - botFlow Function

**Date:** 2026-01-26
**Method:** AWS X-Ray tracing
**Sample Size:** 50 invocations

## Executive Summary

Key bottlenecks identified through X-Ray profiling.

## Top 5 Bottlenecks

### 1. [Bottleneck Name]

- **Location:** [file:function]
- **Average Duration:** [X]ms
- **Frequency:** [X]% of invocations
- **Root Cause:** [description]
- **Impact:** [HIGH/MEDIUM/LOW]
- **Optimization Potential:** [X]ms improvement possible

### 2. [Bottleneck Name]

...

## DynamoDB Analysis

### Query Performance

| Operation        | Count | Avg Duration | P90 Duration | Optimization Opportunity |
| ---------------- | ----- | ------------ | ------------ | ------------------------ |
| GetItem (states) | [X]   | [X]ms        | [X]ms        | [Yes/No] - [reason]      |
| PutItem (states) | [X]   | [X]ms        | [X]ms        | [Yes/No] - [reason]      |
| Query (channels) | [X]   | [X]ms        | [X]ms        | [Yes/No] - [reason]      |

### Identified Issues

1. **Sequential Queries:** [X] queries executed sequentially that could be batched
2. **Missing Indexes:** [list any missing GSI opportunities]
3. **Over-fetching:** [any queries retrieving unnecessary data]

## External API Analysis

### Latency Breakdown

| Service      | Avg Latency | P90 Latency | Calls per Invocation | Optimization  |
| ------------ | ----------- | ----------- | -------------------- | ------------- |
| DailyBot API | [X]ms       | [X]ms       | [X]                  | [opportunity] |
| Slack API    | [X]ms       | [X]ms       | [X]                  | [opportunity] |
| Discord API  | [X]ms       | [X]ms       | [X]                  | [opportunity] |

### Connection Patterns

- [ ] Connection pooling in use? NO → Opportunity
- [ ] Parallel calls where possible? PARTIAL → Opportunity
- [ ] Proper timeout configuration? YES

## Memory Analysis

### Memory Usage Pattern

- **Average Memory Used:** [X]MB
- **Peak Memory Used:** [X]MB
- **Memory Allocated:** 512MB
- **Utilization:** [X]%

### Memory-Intensive Operations

1. [Operation]: [X]MB allocated
2. [Operation]: [X]MB allocated

## Initialization Time Breakdown

| Phase                  | Duration | % of Cold Start |
| ---------------------- | -------- | --------------- |
| Runtime initialization | [X]ms    | [X]%            |
| Module imports         | [X]ms    | [X]%            |
| AWS SDK initialization | [X]ms    | [X]%            |
| Custom initialization  | [X]ms    | [X]%            |
| **Total Cold Start**   | [X]ms    | 100%            |

### Import Analysis

- Total imports: [X]
- Largest import: [module] ([X]ms)
- Unnecessary imports: [list if any]

## Recommendations Priority

### High Priority (Tasks 3-5)

1. **Optimize webpack bundle** - [X]ms improvement
2. **Implement DynamoDB batch operations** - [X]ms improvement
3. **Add connection pooling** - [X]ms improvement

### Medium Priority (Tasks 6-7)

4. **Increase Lambda memory** - [X]ms improvement
5. **Implement caching** - [X]ms improvement

### Low Priority (Task 8)

6. **Optimize logging** - [X]ms improvement

## Expected Total Improvement

- **Cold Start:** [X]s → [X]s (reduction of [X]%)
- **Execution Time:** [X]ms → [X]ms (reduction of [X]%)
- **Cost Reduction:** $[X]/month

## Next Steps

Proceed to Task 3 (Webpack Bundle Optimization) as the highest impact optimization.
```

---

## 4. Acceptance Criteria

- [ ] AWS X-Ray enabled for botFlow Lambda
- [ ] X-Ray SDK integrated in code
- [ ] 50+ representative invocations profiled
- [ ] All platforms tested (Slack, Discord, Teams, Telegram)
- [ ] Service map reviewed and documented
- [ ] Top 5 bottlenecks identified with durations
- [ ] DynamoDB query patterns analyzed
- [ ] External API latencies measured
- [ ] Memory usage patterns documented
- [ ] Profiling report created at `docs/profiling-report-2026-01-26.md`
- [ ] Recommendations prioritized by impact

---

## 5. Validation

```bash
# Verify X-Ray is enabled
aws lambda get-function --function-name botFlow-dev | grep TracingConfig

# Check X-Ray traces exist
aws xray get-trace-summaries --start-time [timestamp] --end-time [timestamp]

# Verify profiling report exists
cat docs/profiling-report-2026-01-26.md | grep -E "Bottleneck|DynamoDB|Recommendation"

# Run tests to ensure X-Ray integration doesn't break anything
npm run test

# Run code quality checks
codecheck
```

---

## 6. Execution Checklist

- [ ] 1. Read this task file fully and understand the goal
- [ ] 2. Enable AWS X-Ray in Serverless configuration
- [ ] 3. Add X-Ray SDK to code and instrument AWS SDK calls
- [ ] 4. Deploy changes to dev environment
- [ ] 5. Generate representative traffic (50+ invocations)
- [ ] 6. Review X-Ray Service Map
- [ ] 7. Analyze trace timelines and durations
- [ ] 8. Identify DynamoDB bottlenecks
- [ ] 9. Identify external API bottlenecks
- [ ] 10. Analyze memory usage patterns
- [ ] 11. Create comprehensive profiling report
- [ ] 12. Prioritize recommendations by impact
- [ ] 13. Run validation commands
- [ ] 14. Update the plan README to mark this task as `[x]`
- [ ] 15. Commit with message: `perf(lambda): add X-Ray profiling and identify bottlenecks`
- [ ] 16. Update the Log section below

---

## 7. Completion & Log

**Status:** Not started

<!-- Agent fills this section when task is complete -->

**Completion Details:**

- Timestamp:
- Duration:
- Files created:
  - docs/profiling-report-2026-01-26.md
- Files modified:
  - serverless/services/botFlow/serverless.yml
  - src/functions/botFlow/handler.ts
  - package.json
- Key findings:
  - Top bottleneck:
  - Expected improvement:
  - Next priority task:
- Notes:
